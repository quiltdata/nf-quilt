import io.nextflow.gradle.tasks.GithubRepositoryPublisher
import io.nextflow.gradle.tasks.GithubUploader
import org.apache.commons.codec.digest.DigestUtils
import org.codehaus.groovy.runtime.GStringImpl

import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

/*
 * Copyright 2021-2022, Seqera Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
 * of any kind, either express or implied.
 * See the License for specific language governing permissions and limitations.
 */

plugins {
    id 'java'
    id 'groovy'
    id 'io.nextflow.nf-build-plugin' version '1.0.1'
}

/* Project Constants */
ext {
    github_organization = project.findProperty('github_organization') ?: 'nextflow-io'
    github_username = project.findProperty('github_username') ?: 'pditommaso'
    github_access_token = project.findProperty('github_access_token') ?: System.getenv('GITHUB_TOKEN')
    github_commit_email = project.findProperty('github_commit_email') ?: 'paolo.ditommaso@gmail.com'
    github_index_url = "https://github.com/${github_organization}/plugins/main/plugins.json" as GStringImpl
}

// Disable default JAR generation
jar.enabled = false

/* Utility Functions */
static String computeSha512(File file) {
    if (!file.exists()) {
        throw new GradleException("Missing file: $file -- cannot compute SHA-512")
    }
    return DigestUtils.sha512Hex(file.bytes)
}

static String now() {
    "${OffsetDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME)}"
}

List<String> allPlugins() {
    def plugins = []
    new File(rootProject.rootDir, 'plugins').eachDir {
        if (it.name.startsWith('nf-')) plugins.add(it.name)
    }
    return plugins
}

String metaFromManifest(String meta, File file) {
    def str = file.text
    def regex = ~/(?m)^$meta:\s*([\w-\.<>=]+)$/
    def m = regex.matcher(str)
    if (m.find()) {
        def ver = m.group(1)
        println "Set plugin '${file.parentFile.parentFile.parentFile.parentFile.name}' version=$ver"
        return ver
    }
    throw new GradleException("Cannot find '$meta' for plugin: $file")
}

def timestamp = now()

/* Configure Subprojects */
subprojects {
    apply plugin: 'java'
    apply plugin: 'groovy'
    apply plugin: 'io.nextflow.nf-build-plugin'

    repositories {
        mavenLocal()
        mavenCentral()
    }

    version = metaFromManifest('Plugin-Version', file('src/resources/META-INF/MANIFEST.MF'))

    tasks.withType(Jar).configureEach {
        duplicatesStrategy = DuplicatesStrategy.INCLUDE
    }

    /* Plugin Variables */
    String pluginVersion = project.version
    String archiveName = "${project.name}-${pluginVersion}"
    File zipFile = layout.buildDirectory.file("libs/${archiveName}.zip").get().asFile
    File jsonFile = layout.buildDirectory.file("libs/${archiveName}-meta.json").get().asFile
    File pluginsDir = layout.buildDirectory.dir("plugins").get().asFile

    /* Task to Create Plugin Zip and Metadata */
    tasks.register('makeZip', Jar) {
        into('classes') { with jar }
        into('lib') { from configurations.runtimeClasspath }
        manifest.from file('src/resources/META-INF/MANIFEST.MF')
        archiveExtension = 'zip'
        preserveFileTimestamps = false
        reproducibleFileOrder = true

        String downloadUrl = "https://github.com/${github_organization}/${project.name}/releases/download/${pluginVersion}/${archiveName}.zip"
        doLast {
            // Generate the metadata file
            jsonFile.text = """\
{
    "version": "${pluginVersion}",
    "date": "${timestamp}",
    "url": "${downloadUrl}",
    "requires": "${metaFromManifest('Plugin-Requires', file('src/resources/META-INF/MANIFEST.MF'))}",
    "sha512sum": "${computeSha512(zipFile)}"
}
"""
        }
        outputs.file(zipFile)
    }

    /* Task to Copy Plugin Dependencies */
    tasks.register('copyPluginLibs', Sync) {
        from configurations.runtimeClasspath
        into 'build/target/libs'
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }

    /* Task to Copy Plugin ZIP to Plugins Directory */
    tasks.register('copyPluginZip', Copy) {
        dependsOn project.tasks.named('makeZip')
        from { tasks.named('makeZip').get().outputs.files.singleFile }
        into pluginsDir.absolutePath
        outputs.file(zipFile)

        def destDirPath = new File(pluginsDir, archiveName).absolutePath
        doLast {
            if (!zipFile.exists()) {
                throw new GradleException("File ${zipFile} does not exist! Cannot unzip.")
            }
            ant.unzip(
                    src: zipFile.absolutePath,
                    dest: destDirPath
            )
        }
    }
    
    /* "Install" the Plugin */
    def providerList = [zipFile.absolutePath, jsonFile.absolutePath]
    project.parent.tasks.named('assemble').configure {
        dependsOn(copyPluginZip)
    }
    tasks.register('uploadPlugin', GithubUploader) {
        dependsOn tasks.named('makeZip') // Lazy dependency
        assets = providers.provider { providerList } as Provider<? extends Iterable<? extends String>>
        release = providers.provider { project.version } as Provider<? extends String>
        repo = providers.provider { project.name }
        owner = github_organization
        userName = github_username
        authToken = github_access_token
        skipExisting = true
    }
}

/* Upload Task */
tasks.register('upload') {
    dependsOn subprojects.uploadPlugin
}

classes.dependsOn subprojects.copyPluginLibs

/* Publish Plugins Index File */
tasks.register('publishIndex', GithubRepositoryPublisher) {
    indexUrl = github_index_url
    repos = allPlugins()
    owner = github_organization
    githubUser = github_username
    githubEmail = github_commit_email
    githubToken = github_access_token
}
